import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;

import javax.swing.*;
import java.awt.*;

public class SortingPerformanceChart {

    public static void main(String[] args) {
        XYSeriesCollection dataset = new XYSeriesCollection();

        // Arrays of different sizes
        int[] sizes = {100, 1000, 10000, 100000};

        // Sorting algorithms
        String[] algorithms = {"Bubble Sort", "Selection Sort", "Insertion Sort"};

        // Populate dataset
        for (String algorithm : algorithms) {
            XYSeries series = new XYSeries(algorithm);
            for (int size : sizes) {
                long executionTime = measureExecutionTime(algorithm, size);
                series.add(size, executionTime);
            }
            dataset.addSeries(series);
        }

        // Create chart
        JFreeChart chart = ChartFactory.createXYLineChart(
                "Sorting Algorithm Performance",
                "Array Size",
                "Execution Time (ms)",
                dataset
        );

        // Display chart
        SwingUtilities.invokeLater(() -> {
            ChartPanel panel = new ChartPanel(chart);
            JFrame frame = new JFrame("Sorting Algorithm Performance");
            frame.setSize(800, 600);
            frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
            frame.getContentPane().add(panel, BorderLayout.CENTER);
            frame.setVisible(true);
        });
    }

    // Method to measure execution time for a sorting algorithm and array size
    public static long measureExecutionTime(String algorithm, int size) {
        int[] array = generateArray(size);
        long startTime = System.nanoTime();
        switch (algorithm) {
            case "Bubble Sort":
                SortingPerformance.bubbleSort(array);
                break;
            case "Selection Sort":
                SortingPerformance.selectionSort(array);
                break;
            case "Insertion Sort":
                SortingPerformance.insertionSort(array);
                break;
        }
        long endTime = System.nanoTime();
        return (endTime - startTime) / 1000000; // Convert to milliseconds
    }

    // Method to generate an array of random integers
    public static int[] generateArray(int size) {
        int[] array = new int[size];
        for (int i = 0; i < size; i++) {
            array[i] = (int) (Math.random() * 1000); // Generate random integers between 0 and 999
        }
        return array;
    }
}
